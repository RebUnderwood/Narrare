{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Narr\u0101re A Godot-based framework for making text-based adventure games and interactive fiction! Get Narr\u0101re! Warning: These docs are outdated! The dev is currently working to update them; we appreciate your patience. Back in Ye Olden Days, games like Zork and Anchorhead used the medium of text to create elaborate, interactive worlds. Through intuitive, natural language, players could interact with these worlds naturally, exploring them at their whim. Nowadays, this genre of game has largely faded from the minds of all but the truly niche-minded, and part of the reason for that is that the tools for creating them have not evolved with the rest of the gaming landscape. The most popular software for producing interactive fiction, Inform 7, is very good at what it does, but does not offer the full capabilities of a modern game engine. I developed Narr\u0101re because I wanted to make text-based games that could do more . It's a framework for the Godot game engine that takes most of the difficult work of developing these types of games out of the equation, but because it's based in Godot, you get all the power and capabilities of Godot too. Custom interfaces, sprites, 3D animations, minigames\u2014whatever you want to make, you can build it on top of Narr\u0101re. Narr\u0101re is also designed with the technical-minded in mind. If you want to get into the nuts and bolts, you can. Create your own commands, implement complex logic, whatever you want to do.","title":"Home"},{"location":"#narrare","text":"A Godot-based framework for making text-based adventure games and interactive fiction!","title":"Narr\u0101re"},{"location":"#warning-these-docs-are-outdated-the-dev-is-currently-working-to-update-them-we-appreciate-your-patience","text":"Back in Ye Olden Days, games like Zork and Anchorhead used the medium of text to create elaborate, interactive worlds. Through intuitive, natural language, players could interact with these worlds naturally, exploring them at their whim. Nowadays, this genre of game has largely faded from the minds of all but the truly niche-minded, and part of the reason for that is that the tools for creating them have not evolved with the rest of the gaming landscape. The most popular software for producing interactive fiction, Inform 7, is very good at what it does, but does not offer the full capabilities of a modern game engine. I developed Narr\u0101re because I wanted to make text-based games that could do more . It's a framework for the Godot game engine that takes most of the difficult work of developing these types of games out of the equation, but because it's based in Godot, you get all the power and capabilities of Godot too. Custom interfaces, sprites, 3D animations, minigames\u2014whatever you want to make, you can build it on top of Narr\u0101re. Narr\u0101re is also designed with the technical-minded in mind. If you want to get into the nuts and bolts, you can. Create your own commands, implement complex logic, whatever you want to do.","title":"Warning: These docs are outdated! The dev is currently working to update them; we appreciate your patience."},{"location":"getting_started/","text":"Getting Started Most of Narr\u0101re's internal logic is housed within the Narr\u0101re Core folder. You will probably not need to modify anything in there unless you are making fundamental changes to Narr\u0101re. Exposed to the user are the Narrare global script, the Room and Map classes, and the Prompt and InputRequest classes, which will be basic building blocks of your game. Additionally, in the Root folder of the project is a folder called Scripts. This contains three scripts by default: Commands , Data , and Interactables . These you should modify, as they are integral to the logic of your game. Commands defines what commands will be available for the player to use; Data will contain any variables you need to track game state; and Interactables defines all the things within the game that can be interacted with and how. The template by default has a fully-featured example game in it which you can use for reference or to get started quickly. Feel free to use, change, or remove anything and everything as needed! Experiment! Go wild!","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"Most of Narr\u0101re's internal logic is housed within the Narr\u0101re Core folder. You will probably not need to modify anything in there unless you are making fundamental changes to Narr\u0101re. Exposed to the user are the Narrare global script, the Room and Map classes, and the Prompt and InputRequest classes, which will be basic building blocks of your game. Additionally, in the Root folder of the project is a folder called Scripts. This contains three scripts by default: Commands , Data , and Interactables . These you should modify, as they are integral to the logic of your game. Commands defines what commands will be available for the player to use; Data will contain any variables you need to track game state; and Interactables defines all the things within the game that can be interacted with and how. The template by default has a fully-featured example game in it which you can use for reference or to get started quickly. Feel free to use, change, or remove anything and everything as needed! Experiment! Go wild!","title":"Getting Started"},{"location":"documentation/command/","text":"Command Class Commands are how the player interacts with the game. For example, a common command in many text-based adventure games is some variant of 'go' followed by a cardinal direction, which allows movement between rooms. Commands in Narr\u0101re take the form of Command objects, which must be added to the command stack in the Commands script. Commands have essentially two components: a Regular Expression pattern, which is used to match the command against user input, and a callable, which is what is executed when the Command is matched. Constructing a Command You can construct a new Command using Command.new(regex_string: String, in_callable: Callable) . Here's an example, a Command for 'echo' that returns whatever the player said: var echo_callable: Callable = ( func(_interactables: InteractablesInterface, matches: RegExMatch) -> String: var out: String = \"\" var echo_phrase: String = matches.get_string(\"phrase_group\"); if echo_phrase.is_empty(): out = \"Echo what?\"; else: out = echo_phrase; return out; ); var echo_command = Command.new(\"^echo ?(?'phrase_group'.+)?\", echo_callable); Note that the callable has a very specific function signature. It should take two arguments: an InteractablesInterface and a RegExMatch . The InteractablesInterface will contain all of the Interactables that are available to the player, both from the current Room and the player's inventory (see Data ). The RegExMatch will contain any matching groups from the Command's pattern; this is where you'll be able to access any arguments the player supplied. Additionally, the callable should return a String . This string is what will be presented to the player as the result of executing the command they inputted. In our above 'echo' example, if the player typed 'echo Hello world!' then the returned value from the callable is \"hello world!\" (commands are lowercased as part of the process of matching) and so this is what will be shown to the player using Narrare.say . Functions attempt_match_execute attempt_match_execute(input_string: String, interactables: InteractablesInterface) -> Variant Attempts to match input_string against the Command's Regular Expression pattern. If the pattern matches, the Command will be executed and the callable will be called, returning its result. If the pattern does not match the input, then null is returned.","title":"Command"},{"location":"documentation/command/#command-class","text":"Commands are how the player interacts with the game. For example, a common command in many text-based adventure games is some variant of 'go' followed by a cardinal direction, which allows movement between rooms. Commands in Narr\u0101re take the form of Command objects, which must be added to the command stack in the Commands script. Commands have essentially two components: a Regular Expression pattern, which is used to match the command against user input, and a callable, which is what is executed when the Command is matched.","title":"Command Class"},{"location":"documentation/command/#constructing-a-command","text":"You can construct a new Command using Command.new(regex_string: String, in_callable: Callable) . Here's an example, a Command for 'echo' that returns whatever the player said: var echo_callable: Callable = ( func(_interactables: InteractablesInterface, matches: RegExMatch) -> String: var out: String = \"\" var echo_phrase: String = matches.get_string(\"phrase_group\"); if echo_phrase.is_empty(): out = \"Echo what?\"; else: out = echo_phrase; return out; ); var echo_command = Command.new(\"^echo ?(?'phrase_group'.+)?\", echo_callable); Note that the callable has a very specific function signature. It should take two arguments: an InteractablesInterface and a RegExMatch . The InteractablesInterface will contain all of the Interactables that are available to the player, both from the current Room and the player's inventory (see Data ). The RegExMatch will contain any matching groups from the Command's pattern; this is where you'll be able to access any arguments the player supplied. Additionally, the callable should return a String . This string is what will be presented to the player as the result of executing the command they inputted. In our above 'echo' example, if the player typed 'echo Hello world!' then the returned value from the callable is \"hello world!\" (commands are lowercased as part of the process of matching) and so this is what will be shown to the player using Narrare.say .","title":"Constructing a Command"},{"location":"documentation/command/#functions","text":"","title":"Functions"},{"location":"documentation/command/#attempt_match_execute","text":"attempt_match_execute(input_string: String, interactables: InteractablesInterface) -> Variant Attempts to match input_string against the Command's Regular Expression pattern. If the pattern matches, the Command will be executed and the callable will be called, returning its result. If the pattern does not match the input, then null is returned.","title":"attempt_match_execute"},{"location":"documentation/commands/","text":"Commands Script The Commands script (Scripts/Commands.gd) is used to define and register your game's commands. Commands are how the player interacts with the game. For example, a common command in many text-based adventure games is some variant of 'go' followed by a cardinal direction, which allows movement between rooms. A number of example commands have been included in this file in the template; feel free to add, remove, or modify them as needed! Commands in Narr\u0101re take the form of Command objects, which are stored in this script's command stack. The command stack is an Array of Command s that, when Commands.parse_command is called, are iterated through in an attempt to match the input from the player against each Command 's pattern. When a match is found, parse_command stops and that Command is executed. Because of this, the order of Command s in the command stack is important. For example, a common command is 'then'. 'then' takes two other commands to either side of itself and performs them in sequence, meaning the player can input multiple commands in one step. If 'then' was placed after our previous 'go' command in the command stack then the input command \"go east then go west\" would only execute 'go east' because it matches the first go command and then stops. To get the correct behaviour, we would want to have 'then' before 'go' in the command stack, because in that case 'then' is matched first and can then execute the two 'go's correctly. This script is global and can be accessed using Commands . More information about its methods can be found in the documentation for the CommandsBase class, which this script extends. Tutorial Let's look at how to add commands. First, we'll crreate two Command s: 'look' and 'take': var look_callable: Callable = ( func(interactables: InteractablesInterface, matches: RegExMatch) -> String: var out: String = \"\" var at_object: String = matches.get_string(\"at_group\"); if at_object.is_empty(): if matches.get_string(\"has_at\").is_empty(): out = Narrare.map.get_room_description(); Narrare.previous_text_displayed = out; else: out = \"Look at what?\"; else: var result: Variant = interactables.attempt_interaction(at_object, \"look\"); if result == null: out = \"You're not sure what you're looking at.\" else: out = result; Narrare.previous_text_displayed = out; return out; ); var look_command = Command.new(\"^look(?: (?'has_at'at))?(?: (?'at_group'[\\\\w ]+))?\", look_callable); var take_callable: Callable = ( func(interactables: InteractablesInterface, matches: RegExMatch) -> String: var out: String = \"\" var take_object: String = matches.get_string(\"take_group\"); if take_object.is_empty(): out = \"Take what?\"; else: var result: Variant = interactables.attempt_interaction(take_object, \"take\"); if result == null: out = \"You're not sure how to take that.\" else: out = result; Narrare.previous_text_displayed = out; return out; ); var take_command = Command.new(\"^take(?: (?'take_group'[\\\\w ]+))?\", take_callable); Now, we can set the command stack. This is done in the Commands script's _ready() function like so: func _ready() -> void: set_command_stack([ look_command, take_command, ]); And that's it! Now, if we were to call Commands.parse_command like so: Commands.parse_command(\"look at box\"); Commands.parse_command will match the 'look' Command 's pattern and execute it. Note again that because 'look' comes before 'take' in the command stack, Narr\u0101re will attempt to match to the 'look' command before it tries to match to the 'take' command. Keep this in mind When setting up your stack!","title":"Commands"},{"location":"documentation/commands/#commands-script","text":"The Commands script (Scripts/Commands.gd) is used to define and register your game's commands. Commands are how the player interacts with the game. For example, a common command in many text-based adventure games is some variant of 'go' followed by a cardinal direction, which allows movement between rooms. A number of example commands have been included in this file in the template; feel free to add, remove, or modify them as needed! Commands in Narr\u0101re take the form of Command objects, which are stored in this script's command stack. The command stack is an Array of Command s that, when Commands.parse_command is called, are iterated through in an attempt to match the input from the player against each Command 's pattern. When a match is found, parse_command stops and that Command is executed. Because of this, the order of Command s in the command stack is important. For example, a common command is 'then'. 'then' takes two other commands to either side of itself and performs them in sequence, meaning the player can input multiple commands in one step. If 'then' was placed after our previous 'go' command in the command stack then the input command \"go east then go west\" would only execute 'go east' because it matches the first go command and then stops. To get the correct behaviour, we would want to have 'then' before 'go' in the command stack, because in that case 'then' is matched first and can then execute the two 'go's correctly. This script is global and can be accessed using Commands . More information about its methods can be found in the documentation for the CommandsBase class, which this script extends.","title":"Commands Script"},{"location":"documentation/commands/#tutorial","text":"Let's look at how to add commands. First, we'll crreate two Command s: 'look' and 'take': var look_callable: Callable = ( func(interactables: InteractablesInterface, matches: RegExMatch) -> String: var out: String = \"\" var at_object: String = matches.get_string(\"at_group\"); if at_object.is_empty(): if matches.get_string(\"has_at\").is_empty(): out = Narrare.map.get_room_description(); Narrare.previous_text_displayed = out; else: out = \"Look at what?\"; else: var result: Variant = interactables.attempt_interaction(at_object, \"look\"); if result == null: out = \"You're not sure what you're looking at.\" else: out = result; Narrare.previous_text_displayed = out; return out; ); var look_command = Command.new(\"^look(?: (?'has_at'at))?(?: (?'at_group'[\\\\w ]+))?\", look_callable); var take_callable: Callable = ( func(interactables: InteractablesInterface, matches: RegExMatch) -> String: var out: String = \"\" var take_object: String = matches.get_string(\"take_group\"); if take_object.is_empty(): out = \"Take what?\"; else: var result: Variant = interactables.attempt_interaction(take_object, \"take\"); if result == null: out = \"You're not sure how to take that.\" else: out = result; Narrare.previous_text_displayed = out; return out; ); var take_command = Command.new(\"^take(?: (?'take_group'[\\\\w ]+))?\", take_callable); Now, we can set the command stack. This is done in the Commands script's _ready() function like so: func _ready() -> void: set_command_stack([ look_command, take_command, ]); And that's it! Now, if we were to call Commands.parse_command like so: Commands.parse_command(\"look at box\"); Commands.parse_command will match the 'look' Command 's pattern and execute it. Note again that because 'look' comes before 'take' in the command stack, Narr\u0101re will attempt to match to the 'look' command before it tries to match to the 'take' command. Keep this in mind When setting up your stack!","title":"Tutorial"},{"location":"documentation/commandsbase/","text":"CommandsBase Class","title":"CommandsBase"},{"location":"documentation/commandsbase/#commandsbase-class","text":"","title":"CommandsBase Class"},{"location":"documentation/data/","text":"Data Script The Data script (Scripts/Data.gd) can be used to store data related to the game state. Things like the player's name, event flags, etc. It is a global script, meaning it can be accessed from anywhere in the project by using 'Data.my_variable_name.' Information should be stored in Data as variables: var player_name: String = \"Stranger\"; var my_flag: bool = false; NOTE: Every variable in the Data script must be of a type that is able to be converted to JSON by JSON.stringify() . This is because the contents of the Data script are converted into a Dictionary and stored as JSON when calling Narrare.save() . For more information on saving, see Narrare . The Data script comes with a variable and methods related to storing and retrieving a player's inventory. These are defined in the DataBase class, which the Data script extends. Variables player_inventory player_inventory: PackedStringArray; The player's inventory. Contains a PackedStringArray of identifiers of Interactable s which reference Interactable s defined in the Interactables script. To add an Interactable to the player's inventory, use add_to_inventory . To remove an item, use remove_from_inventory . You can use get_inventory to access this property. Note that Interactable in the player's inventory must be stored in the Interactables script, NOT in a Room 's room_interactables property. Functions add_to_inventory add_to_inventory(item_name: String) -> void Adds an interactable name to the player's inventory. remove_from_inventory remove_from_inventory(item_name: String) -> bool Removes an interactable by name from the player's inventory. Returns false if that interactable name wasn't found in the inventory, otherwise returns true . get_inventory get_inventory() -> PackedStringArray Gets the player's inventory. to_dict to_dict() -> Dictionary Converts this script's properties into a Dictionary . Called when using Narrare.save() . from_dict from_dict(in_data_dict: Dictionary) -> void Takes a Dictionary in_data_dict generated by to_dict and sets the contents of the Data script to equal the values in in_data_dict . Called when using Narrare.load() .","title":"Data"},{"location":"documentation/data/#data-script","text":"The Data script (Scripts/Data.gd) can be used to store data related to the game state. Things like the player's name, event flags, etc. It is a global script, meaning it can be accessed from anywhere in the project by using 'Data.my_variable_name.' Information should be stored in Data as variables: var player_name: String = \"Stranger\"; var my_flag: bool = false; NOTE: Every variable in the Data script must be of a type that is able to be converted to JSON by JSON.stringify() . This is because the contents of the Data script are converted into a Dictionary and stored as JSON when calling Narrare.save() . For more information on saving, see Narrare . The Data script comes with a variable and methods related to storing and retrieving a player's inventory. These are defined in the DataBase class, which the Data script extends.","title":"Data Script"},{"location":"documentation/data/#variables","text":"","title":"Variables"},{"location":"documentation/data/#player_inventory","text":"player_inventory: PackedStringArray; The player's inventory. Contains a PackedStringArray of identifiers of Interactable s which reference Interactable s defined in the Interactables script. To add an Interactable to the player's inventory, use add_to_inventory . To remove an item, use remove_from_inventory . You can use get_inventory to access this property. Note that Interactable in the player's inventory must be stored in the Interactables script, NOT in a Room 's room_interactables property.","title":"player_inventory"},{"location":"documentation/data/#functions","text":"","title":"Functions"},{"location":"documentation/data/#add_to_inventory","text":"add_to_inventory(item_name: String) -> void Adds an interactable name to the player's inventory.","title":"add_to_inventory"},{"location":"documentation/data/#remove_from_inventory","text":"remove_from_inventory(item_name: String) -> bool Removes an interactable by name from the player's inventory. Returns false if that interactable name wasn't found in the inventory, otherwise returns true .","title":"remove_from_inventory"},{"location":"documentation/data/#get_inventory","text":"get_inventory() -> PackedStringArray Gets the player's inventory.","title":"get_inventory"},{"location":"documentation/data/#to_dict","text":"to_dict() -> Dictionary Converts this script's properties into a Dictionary . Called when using Narrare.save() .","title":"to_dict"},{"location":"documentation/data/#from_dict","text":"from_dict(in_data_dict: Dictionary) -> void Takes a Dictionary in_data_dict generated by to_dict and sets the contents of the Data script to equal the values in in_data_dict . Called when using Narrare.load() .","title":"from_dict"},{"location":"documentation/inputrequest/","text":"TBD","title":"InputRequest"},{"location":"documentation/inputrequest/#tbd","text":"","title":"TBD"},{"location":"documentation/interactable/","text":"Interactable Class In Narr\u0101re, objects and people and anything you can interact with in a game are defined as an Interactable. Interactables may have multiple interactions , which define the ways an Interactable can be interacted with. Interactables are identified by an identifier, which is a String that is unique to them within their context. The identifier should be the exact string you want the player to interact with this Interactable using. For example, if you want the player to be able to type \"open box\" then the identifier for that Interactable should be \"box\". Constructing an Interactable You can construct an Interactable using Interactable.new(identifier: String) . Let's make a new Interactable with the identifier 'box': var box_interactable: Interactable = Interactable.new(\"box\"); Great! We now have an Interactable. Let's add some interactions next using add_interaction : box_interactable.add_interaction(\"look\", func () -> String: return \"It's a box!\"); box_interactable.add_interaction(\"open\", func () -> String: return \"There's nothing inside! What a rip-off.\") Now we have two ways we can interact with this Interactable: 'look' and 'open'. Incidentally, these methods can be chained, which results in slightly cleaner code: var box_interactable: Interactable = Interactable.new(\"box\")\\ .add_interaction(\"look\", func () -> String: return \"It's a box!\")\\ .add_interaction(\"open\", func () -> String: return \"There's nothing inside! What a rip-off.\"); Now that we have some interactions, we can attempt an interaction with attempt_interaction : print(box_interactable.attempt_interaction(\"open\", [])); # prints, 'There's nothing inside! What a rip-off.' Note that you will typically not have to use this method; instead, you will usually be working through an InteractablesInterface and should instead use that class' attempt_interaction method. Functions add_interaction add_interaction(interaction_identifier: String, interaction: Callable) -> Interactable Adds an interaction to this Interactable. The interaction will be identified by interaction_identifier . interaction should be a callable; it can take any number of arguments (it is called using Callable.callv , meaning you don't have to worry about unpacking arguments when called from attempt_interaction ) and can return whatever you want, though typically this will be a String which will be output to the player. This method returns self , making it chainable. attempt_interaction attempt_interaction(interaction_identifier: String, args: Array) -> Variant Attempts to call the interaction with identifier interaction_identifier and arguments args (it is called using Callable.callv , meaning you don't have to worry about unpacking args) If the interaction exists within this Interactable, the result of the interaction Callable will be returned. If it doesn't exist, null is returned.","title":"Interactable"},{"location":"documentation/interactable/#interactable-class","text":"In Narr\u0101re, objects and people and anything you can interact with in a game are defined as an Interactable. Interactables may have multiple interactions , which define the ways an Interactable can be interacted with. Interactables are identified by an identifier, which is a String that is unique to them within their context. The identifier should be the exact string you want the player to interact with this Interactable using. For example, if you want the player to be able to type \"open box\" then the identifier for that Interactable should be \"box\".","title":"Interactable Class"},{"location":"documentation/interactable/#constructing-an-interactable","text":"You can construct an Interactable using Interactable.new(identifier: String) . Let's make a new Interactable with the identifier 'box': var box_interactable: Interactable = Interactable.new(\"box\"); Great! We now have an Interactable. Let's add some interactions next using add_interaction : box_interactable.add_interaction(\"look\", func () -> String: return \"It's a box!\"); box_interactable.add_interaction(\"open\", func () -> String: return \"There's nothing inside! What a rip-off.\") Now we have two ways we can interact with this Interactable: 'look' and 'open'. Incidentally, these methods can be chained, which results in slightly cleaner code: var box_interactable: Interactable = Interactable.new(\"box\")\\ .add_interaction(\"look\", func () -> String: return \"It's a box!\")\\ .add_interaction(\"open\", func () -> String: return \"There's nothing inside! What a rip-off.\"); Now that we have some interactions, we can attempt an interaction with attempt_interaction : print(box_interactable.attempt_interaction(\"open\", [])); # prints, 'There's nothing inside! What a rip-off.' Note that you will typically not have to use this method; instead, you will usually be working through an InteractablesInterface and should instead use that class' attempt_interaction method.","title":"Constructing an Interactable"},{"location":"documentation/interactable/#functions","text":"","title":"Functions"},{"location":"documentation/interactable/#add_interaction","text":"add_interaction(interaction_identifier: String, interaction: Callable) -> Interactable Adds an interaction to this Interactable. The interaction will be identified by interaction_identifier . interaction should be a callable; it can take any number of arguments (it is called using Callable.callv , meaning you don't have to worry about unpacking arguments when called from attempt_interaction ) and can return whatever you want, though typically this will be a String which will be output to the player. This method returns self , making it chainable.","title":"add_interaction"},{"location":"documentation/interactable/#attempt_interaction","text":"attempt_interaction(interaction_identifier: String, args: Array) -> Variant Attempts to call the interaction with identifier interaction_identifier and arguments args (it is called using Callable.callv , meaning you don't have to worry about unpacking args) If the interaction exists within this Interactable, the result of the interaction Callable will be returned. If it doesn't exist, null is returned.","title":"attempt_interaction"},{"location":"documentation/interactables/","text":"Interactables Script The Interactables script (Scripts/Interactables.gd) should be used to store any Interactable s that need to be accessed across Room s, i.e. Interactable s that can be added to the player's inventory (see Data ) or Interactable s that move between different Room s. For Room -specific Interactable s, use that Room 's room_interactables property. The Interactables script extends InteractableInterface , so for more detailed information at associated methods, look there. Interactable s within a given InteractableInterface (like the Interactables script) should all be given unique identifiers. The identifier should be identical to the name of the object you want the player to use to interact with it, i.e. if you want the player to be able to type \"open box\" then the identifier for that Interactable should be \"box\". Interactable s in this script will override Interactable s with the same identifier in a Room 's room_interactables property, so consider anything defined here to be a unique object that should not be replicated elsewhere. Tutorial Let's look at how to add Interactable s. Let's make a new Interactable called 'box' in our Interactables script: var box_interactable = Interactable.new(\"box\"); It doesn't have any interactions, so it's pretty useless right now. Let's add one called 'open': box_interactable.add_interaction(\"open\", func () -> String: return \"There's nothing inside! What a rip-off.\") Now, we can register our box to the Interactables script by calling add_interactables in the script's _ready() function: func _ready() -> void: add_interactables([ box_interactable, ]); And that's it! Now we can access that interactable by name from anywhere in the project with get_interactable or attempt an interaction with it with attempt_interaction : var gotten_box = Interactables.get_interactable(\"box\"); print(Interactables.attempt_interaction(\"box\", \"open\"));","title":"Interactables"},{"location":"documentation/interactables/#interactables-script","text":"The Interactables script (Scripts/Interactables.gd) should be used to store any Interactable s that need to be accessed across Room s, i.e. Interactable s that can be added to the player's inventory (see Data ) or Interactable s that move between different Room s. For Room -specific Interactable s, use that Room 's room_interactables property. The Interactables script extends InteractableInterface , so for more detailed information at associated methods, look there. Interactable s within a given InteractableInterface (like the Interactables script) should all be given unique identifiers. The identifier should be identical to the name of the object you want the player to use to interact with it, i.e. if you want the player to be able to type \"open box\" then the identifier for that Interactable should be \"box\". Interactable s in this script will override Interactable s with the same identifier in a Room 's room_interactables property, so consider anything defined here to be a unique object that should not be replicated elsewhere.","title":"Interactables Script"},{"location":"documentation/interactables/#tutorial","text":"Let's look at how to add Interactable s. Let's make a new Interactable called 'box' in our Interactables script: var box_interactable = Interactable.new(\"box\"); It doesn't have any interactions, so it's pretty useless right now. Let's add one called 'open': box_interactable.add_interaction(\"open\", func () -> String: return \"There's nothing inside! What a rip-off.\") Now, we can register our box to the Interactables script by calling add_interactables in the script's _ready() function: func _ready() -> void: add_interactables([ box_interactable, ]); And that's it! Now we can access that interactable by name from anywhere in the project with get_interactable or attempt an interaction with it with attempt_interaction : var gotten_box = Interactables.get_interactable(\"box\"); print(Interactables.attempt_interaction(\"box\", \"open\"));","title":"Tutorial"},{"location":"documentation/interactablesinterface/","text":"InteractablesInterface Class The InteractablesInterface class is used to collect and interact with multiple Interactable s. The Interactables script extends this class, and a Room 's room_interactables property is also an InteractablesInterface. When executing a Command , all the relevant InteractablesInterfaces available to the player are collected into a single InteractablesInterface which is passed to the Command 's Callable . It's a very important class! Functions get_interactable get_interactable(interactable_identifier: String) -> Interactable Returns an Interactable registered to this InteractablesInterface with identifier interactable_identifier . If no Interactable with that identifier is found, returns null . get_all_interactables get_all_interactables() -> Array[Interactable] Returns an Array of all the Interactable s registered to this InteractablesInterface. add_interactable add_interactable(in_interactable: Interactable) -> void Registers an Interactable in_interactable to this InteractablesInterface. add_interactables add_interactables(in_interactables: Array[Interactable]) -> void Registers all Interactable s in in_interactable to this InteractablesInterface. attempt_interaction attempt_interaction(interactable_identifier: String, interaction_identifier: String, ...args: Array) -> Variant Attempts an interaction with identifier interaction_identifier on an Interactable with identifier interactable_identifier with any given arguments args . Arguments can be given as if they were regular arguments to this function; do not give them as an Array . If either no Interactable interactable_identifier is found or that Interactable does not have an interaction interaction_identifier , null will be returned; otherwise, the return value will be the value returned by the interaction.","title":"InteractablesInterface"},{"location":"documentation/interactablesinterface/#interactablesinterface-class","text":"The InteractablesInterface class is used to collect and interact with multiple Interactable s. The Interactables script extends this class, and a Room 's room_interactables property is also an InteractablesInterface. When executing a Command , all the relevant InteractablesInterfaces available to the player are collected into a single InteractablesInterface which is passed to the Command 's Callable . It's a very important class!","title":"InteractablesInterface Class"},{"location":"documentation/interactablesinterface/#functions","text":"","title":"Functions"},{"location":"documentation/interactablesinterface/#get_interactable","text":"get_interactable(interactable_identifier: String) -> Interactable Returns an Interactable registered to this InteractablesInterface with identifier interactable_identifier . If no Interactable with that identifier is found, returns null .","title":"get_interactable"},{"location":"documentation/interactablesinterface/#get_all_interactables","text":"get_all_interactables() -> Array[Interactable] Returns an Array of all the Interactable s registered to this InteractablesInterface.","title":"get_all_interactables"},{"location":"documentation/interactablesinterface/#add_interactable","text":"add_interactable(in_interactable: Interactable) -> void Registers an Interactable in_interactable to this InteractablesInterface.","title":"add_interactable"},{"location":"documentation/interactablesinterface/#add_interactables","text":"add_interactables(in_interactables: Array[Interactable]) -> void Registers all Interactable s in in_interactable to this InteractablesInterface.","title":"add_interactables"},{"location":"documentation/interactablesinterface/#attempt_interaction","text":"attempt_interaction(interactable_identifier: String, interaction_identifier: String, ...args: Array) -> Variant Attempts an interaction with identifier interaction_identifier on an Interactable with identifier interactable_identifier with any given arguments args . Arguments can be given as if they were regular arguments to this function; do not give them as an Array . If either no Interactable interactable_identifier is found or that Interactable does not have an interaction interaction_identifier , null will be returned; otherwise, the return value will be the value returned by the interaction.","title":"attempt_interaction"},{"location":"documentation/map/","text":"TBD","title":"Map"},{"location":"documentation/map/#tbd","text":"","title":"TBD"},{"location":"documentation/narrare_global_script/","text":"Narrare The Narrare global script contains variables, enums, signals, and functions used throughout a Narr\u0101re game. It can be accessed with Narrare from anywhere in the project. For example: Narrare.say(\"Hello world!\"); Enums Direction Direction {NONE, NORTH, NORTHWEST, WEST, SOUTHWEST, SOUTH, SOUTHEAST, EAST, NORTHEAST, UP, DOWN} Indicates a cardinal direction, as well as up or down. Typically used to refer to an exit or entrance to a Room. Signals These signals can be connected to from anywhere in the project. say_something say_something(message: String) Indicates that a String 'message' should be outputted to the player. This will typically be connected to by the interface, but could be used for other purposes as well. clear_output clear_output Indicates that the output should be cleared. done_writing_to_output done_writing_to_output This should be emitted when the interface is done writing something to the output. You do not need to do this if you will not be using this signal. done_writing_to_input done_writing_to_input This should be emitted when the interface is done writing something to the command input. You do not need to do this if you will not be using this signal. prompt_changed prompt_changed(is_prompt: bool) Emitted when a change is made to the Narrare.current_prompt variable; if Narrare.current_prompt has been set to null, is_prompt will be false, otherwise it will be true. input_request_changed input_request_changed(is_input_request: bool) Emitted when a change is made to the Narrare.current_input_request variable; if Narrare.current_input_request has been set to null, is_input_request will be false, otherwise it will be true. Variables map map: Map The current Map. This should be set by the game when a Map node is loaded. previous_text_displayed previous_text_displayed: String The last meaningful text to be output to the player. This text is saved when calling Narrare.save() , and will be output when that save is loaded. It is generally advised that you only set this variable when something useful is output, like the description of a room or the result of interacting with an interactable. data_saved data_saved: bool Should be set to true only if the game state has not been changed since the last time the game was saved. If it is false , a confirmation prompt will be shown when loading a save. Generally you won't have to interact with this variable yourself. current_prompt current_prompt: Prompt If you want to present the player with a Prompt , this variable should be set to that Prompt. Otherwise, it should be null. Changing this variable emits the prompt_changed signal. current_input_request current_input_request: InputRequest ** If you want to present the player with an InputRequest , this variable should be set to that InputRequest. Otherwise, it should be null. Changing this variable emits the input_request_changed signal. Functions say say(message: String) -> void A convenience function. Emits the say_something(message) signal, indicating that message should be output to the player. clear clear() -> void A convenience function. Emits the clear_output signal, indicating that the output should be cleared. save save(save_name: String = \"-----\") -> int Attempts to save the game. Saves are saved to the user://Saves directory. Saves are given a name save_name which will be displayed when calling Narrare.list_saves() . The returned int is the number of the save which will be used to access it by Narrare.load_save(save_number: String) . It will return -1 if the save failed. list_saves list_saves() -> String Returns in String format a list of saves in the user://Saves directory. load_save load_save(save_number: String) -> Dictionary Attempts to load a saved game from the user://Saves directory by save_number. Note that save_number is given as a String; this is because this will be user input. If this function succeeds, the game state will be changed to reflect the data in the loaded save. Returns a Dictionary of the form {\"err\": Error, \"out\": String} where err is a Godot Error enum value and out is a resulting string to output to the user. If Narrare.data_saved is false , a confirmation Prompt will be given to the user before the load goes through.","title":"Narrare"},{"location":"documentation/narrare_global_script/#narrare","text":"The Narrare global script contains variables, enums, signals, and functions used throughout a Narr\u0101re game. It can be accessed with Narrare from anywhere in the project. For example: Narrare.say(\"Hello world!\");","title":"Narrare"},{"location":"documentation/narrare_global_script/#enums","text":"","title":"Enums"},{"location":"documentation/narrare_global_script/#direction","text":"Direction {NONE, NORTH, NORTHWEST, WEST, SOUTHWEST, SOUTH, SOUTHEAST, EAST, NORTHEAST, UP, DOWN} Indicates a cardinal direction, as well as up or down. Typically used to refer to an exit or entrance to a Room.","title":"Direction"},{"location":"documentation/narrare_global_script/#signals","text":"These signals can be connected to from anywhere in the project.","title":"Signals"},{"location":"documentation/narrare_global_script/#say_something","text":"say_something(message: String) Indicates that a String 'message' should be outputted to the player. This will typically be connected to by the interface, but could be used for other purposes as well.","title":"say_something"},{"location":"documentation/narrare_global_script/#clear_output","text":"clear_output Indicates that the output should be cleared.","title":"clear_output"},{"location":"documentation/narrare_global_script/#done_writing_to_output","text":"done_writing_to_output This should be emitted when the interface is done writing something to the output. You do not need to do this if you will not be using this signal.","title":"done_writing_to_output"},{"location":"documentation/narrare_global_script/#done_writing_to_input","text":"done_writing_to_input This should be emitted when the interface is done writing something to the command input. You do not need to do this if you will not be using this signal.","title":"done_writing_to_input"},{"location":"documentation/narrare_global_script/#prompt_changed","text":"prompt_changed(is_prompt: bool) Emitted when a change is made to the Narrare.current_prompt variable; if Narrare.current_prompt has been set to null, is_prompt will be false, otherwise it will be true.","title":"prompt_changed"},{"location":"documentation/narrare_global_script/#input_request_changed","text":"input_request_changed(is_input_request: bool) Emitted when a change is made to the Narrare.current_input_request variable; if Narrare.current_input_request has been set to null, is_input_request will be false, otherwise it will be true.","title":"input_request_changed"},{"location":"documentation/narrare_global_script/#variables","text":"","title":"Variables"},{"location":"documentation/narrare_global_script/#map","text":"map: Map The current Map. This should be set by the game when a Map node is loaded.","title":"map"},{"location":"documentation/narrare_global_script/#previous_text_displayed","text":"previous_text_displayed: String The last meaningful text to be output to the player. This text is saved when calling Narrare.save() , and will be output when that save is loaded. It is generally advised that you only set this variable when something useful is output, like the description of a room or the result of interacting with an interactable.","title":"previous_text_displayed"},{"location":"documentation/narrare_global_script/#data_saved","text":"data_saved: bool Should be set to true only if the game state has not been changed since the last time the game was saved. If it is false , a confirmation prompt will be shown when loading a save. Generally you won't have to interact with this variable yourself.","title":"data_saved"},{"location":"documentation/narrare_global_script/#current_prompt","text":"current_prompt: Prompt If you want to present the player with a Prompt , this variable should be set to that Prompt. Otherwise, it should be null. Changing this variable emits the prompt_changed signal.","title":"current_prompt"},{"location":"documentation/narrare_global_script/#current_input_request","text":"current_input_request: InputRequest ** If you want to present the player with an InputRequest , this variable should be set to that InputRequest. Otherwise, it should be null. Changing this variable emits the input_request_changed signal.","title":"current_input_request"},{"location":"documentation/narrare_global_script/#functions","text":"","title":"Functions"},{"location":"documentation/narrare_global_script/#say","text":"say(message: String) -> void A convenience function. Emits the say_something(message) signal, indicating that message should be output to the player.","title":"say"},{"location":"documentation/narrare_global_script/#clear","text":"clear() -> void A convenience function. Emits the clear_output signal, indicating that the output should be cleared.","title":"clear"},{"location":"documentation/narrare_global_script/#save","text":"save(save_name: String = \"-----\") -> int Attempts to save the game. Saves are saved to the user://Saves directory. Saves are given a name save_name which will be displayed when calling Narrare.list_saves() . The returned int is the number of the save which will be used to access it by Narrare.load_save(save_number: String) . It will return -1 if the save failed.","title":"save"},{"location":"documentation/narrare_global_script/#list_saves","text":"list_saves() -> String Returns in String format a list of saves in the user://Saves directory.","title":"list_saves"},{"location":"documentation/narrare_global_script/#load_save","text":"load_save(save_number: String) -> Dictionary Attempts to load a saved game from the user://Saves directory by save_number. Note that save_number is given as a String; this is because this will be user input. If this function succeeds, the game state will be changed to reflect the data in the loaded save. Returns a Dictionary of the form {\"err\": Error, \"out\": String} where err is a Godot Error enum value and out is a resulting string to output to the user. If Narrare.data_saved is false , a confirmation Prompt will be given to the user before the load goes through.","title":"load_save"},{"location":"documentation/prompt/","text":"TBD","title":"Prompt"},{"location":"documentation/prompt/#tbd","text":"","title":"TBD"},{"location":"documentation/room/","text":"Room Class A Room represents a physical area in the game which the player can travel to and/or be in. It does not have to physically be a room\u2014a garden could be a Room, or part of a hallway, or a graveyard. It's just a container meant to represent a defined area in the game world. You will typically work with Rooms as children of a Map node. Exits A Room has ten defined exits; eight in compass directions, one up and one down. These are represented as variables with the following naming convention: exit_<direction> . For example, the exit to the southeast is exit_southeast . The exit up is exit_up . The exist down is exit_down . By default, these variables are set to null ; to make an exit work, the intended direction's variable should beset as a refrence to another Room. For example, if we have two Rooms, LeftRoom and RightRoom, and LeftRoom is located to the west of RightRoom, LeftRoom's exit_east variable should be set to RightRoom, and likewise RightRoom's exit_west should be set to LeftRoom. This will enable the correct navigation between the two Rooms. These variables are all exports, so they can be easily set in the editor. Describing a Room When looking at a Room or entering one, it is important that the Room be described to the player. In order to do this with some flexibility, multiple variables and functions have been provided to do this. The primary description of a Room should be housed within the look_description variable. This is the description that should be provided when the player looks at the room, and should include information such as what exits are available and any Interactables that may be present. However, there may be cases where the description needs to change depending on outside factors. In order to achieve this, simply override the Room base class' look() function to return a different string: func look() -> String: if !Data.screwdriver_taken: return \"There is an echo in here. There is a [sign] on the wall. Sitting on a table in the corner is a [screwdriver]. A door to the west leads to the Right Room.\" else: return \"There is an echo in here. There is a [sign] on the wall. An empty table sits in the corner. A door to the west leads to the Right Room.\"; By default, all the look() function does is return the look_description variable, so you don't need to accomodate any special logic here. In addition to the look_description variable, there are also the entry_description and enter_<direction>_text variables. Both are used in the Room's enter() function. When navigating into a new Room, the resulting description that is shown to the player comes from calling that room's enter() function. enter() combines several descriptions (including the one produced by look() ) into one description, which it returns. These descriptions are in the following way: room_name enter_<direction>_text entry_description look() room_name is the name of the room, i.e. \"Left Room\". enter_<direction>_text is a String corresponding to the direction the Room was entered from. There is an enter_<direction>_text for each exit_<direction> : exit_southeast corresponds to enter_southeast_text , etc. For example, \"You leave the Right Room, shutting the door behind you.\" entry_description is something that is described when you are in the Room, i.e. \"You are now in the Left Room.\" So, with the previous examples, calling enter() produces the following description: Left Room You leave the Right Room, shutting the door behind you. You are now in the Left Room. There is an echo in here. There is a [sign] on the wall. An empty table sits in the corner. A door to the west leads to the Right Room. Variables exit_<direction> exit_<direction>: Room A set of variables dictating the exits to a Room. There is a corresponding variable for every compass direction as well as up and down. For example, the exit to the southeast is exit_southeast . The exit up is exit_up . The exist down is exit_down . If there is no exit in a given direction, that direction's exit variable should be set to null. Otherwise, it should be set to the Room that is reached by travelling in that direction. enter_<direction>_text enter_<direction>_text: String A set of variables that can be used to provide additional description when entering a Room from a specific direction. There is an enter_<direction>_text for every exit_<direction> . entry_description entry_description: String Used to provide an additional description when entering a room. look_description look_description: String Used to provide a description of the Room. room_name room_name: String In the default look() function, this is returned. Provides a convenient way to set the description of a Room for Rooms whose description does not change. interactables interactables: Array[String] An array of Interactable identifier strings. These can be defined either in the Interactables script or in this Room's room_interactables property. room_interactables room_interactables: InteractablesInterface Used to hold room specific Interactable s. These should be Interactable s that will never leave this room or be used elsewhere; therefore, they can share identifiers with other Interactable s in other Rooms . Notably, they will still be overridden by Interactable s with the same identifier in the Interactables script. For more information on how to interact with this property, see InteractablesInterface . Functions get_room_in_direction get_room_in_direction(direction: Narrare.Direction) -> Room Returns the Room in the corresponding exit to direction , where direction is a Narrare.Direction . Returns null if there is no Room in that exit. look look() -> String By default, returns the value of look_description , but can be overridden for custom behaviour. enter enter(from: Room) -> String BCompiles a description of the player entering the room from room_name , enter_<direction>_text , entry_description , and look() . from should be the Room that the player was in before entering this one. Note: does not actually change the player's position in the map; see Map for information on how to do that. enter_trigger enter_trigger() -> void By default, does nothing, but is called when the Room is entered. Override with custom behaviour if needed. exit_trigger exit_trigger() -> void By default, does nothing, but is called when the Room is exited. Override with custom behaviour if needed.","title":"Room"},{"location":"documentation/room/#room-class","text":"A Room represents a physical area in the game which the player can travel to and/or be in. It does not have to physically be a room\u2014a garden could be a Room, or part of a hallway, or a graveyard. It's just a container meant to represent a defined area in the game world. You will typically work with Rooms as children of a Map node.","title":"Room Class"},{"location":"documentation/room/#exits","text":"A Room has ten defined exits; eight in compass directions, one up and one down. These are represented as variables with the following naming convention: exit_<direction> . For example, the exit to the southeast is exit_southeast . The exit up is exit_up . The exist down is exit_down . By default, these variables are set to null ; to make an exit work, the intended direction's variable should beset as a refrence to another Room. For example, if we have two Rooms, LeftRoom and RightRoom, and LeftRoom is located to the west of RightRoom, LeftRoom's exit_east variable should be set to RightRoom, and likewise RightRoom's exit_west should be set to LeftRoom. This will enable the correct navigation between the two Rooms. These variables are all exports, so they can be easily set in the editor.","title":"Exits"},{"location":"documentation/room/#describing-a-room","text":"When looking at a Room or entering one, it is important that the Room be described to the player. In order to do this with some flexibility, multiple variables and functions have been provided to do this. The primary description of a Room should be housed within the look_description variable. This is the description that should be provided when the player looks at the room, and should include information such as what exits are available and any Interactables that may be present. However, there may be cases where the description needs to change depending on outside factors. In order to achieve this, simply override the Room base class' look() function to return a different string: func look() -> String: if !Data.screwdriver_taken: return \"There is an echo in here. There is a [sign] on the wall. Sitting on a table in the corner is a [screwdriver]. A door to the west leads to the Right Room.\" else: return \"There is an echo in here. There is a [sign] on the wall. An empty table sits in the corner. A door to the west leads to the Right Room.\"; By default, all the look() function does is return the look_description variable, so you don't need to accomodate any special logic here. In addition to the look_description variable, there are also the entry_description and enter_<direction>_text variables. Both are used in the Room's enter() function. When navigating into a new Room, the resulting description that is shown to the player comes from calling that room's enter() function. enter() combines several descriptions (including the one produced by look() ) into one description, which it returns. These descriptions are in the following way: room_name enter_<direction>_text entry_description look() room_name is the name of the room, i.e. \"Left Room\". enter_<direction>_text is a String corresponding to the direction the Room was entered from. There is an enter_<direction>_text for each exit_<direction> : exit_southeast corresponds to enter_southeast_text , etc. For example, \"You leave the Right Room, shutting the door behind you.\" entry_description is something that is described when you are in the Room, i.e. \"You are now in the Left Room.\" So, with the previous examples, calling enter() produces the following description: Left Room You leave the Right Room, shutting the door behind you. You are now in the Left Room. There is an echo in here. There is a [sign] on the wall. An empty table sits in the corner. A door to the west leads to the Right Room.","title":"Describing a Room"},{"location":"documentation/room/#variables","text":"","title":"Variables"},{"location":"documentation/room/#exit_direction","text":"exit_<direction>: Room A set of variables dictating the exits to a Room. There is a corresponding variable for every compass direction as well as up and down. For example, the exit to the southeast is exit_southeast . The exit up is exit_up . The exist down is exit_down . If there is no exit in a given direction, that direction's exit variable should be set to null. Otherwise, it should be set to the Room that is reached by travelling in that direction.","title":"exit_&lt;direction>"},{"location":"documentation/room/#enter_direction_text","text":"enter_<direction>_text: String A set of variables that can be used to provide additional description when entering a Room from a specific direction. There is an enter_<direction>_text for every exit_<direction> .","title":"enter_&lt;direction>_text"},{"location":"documentation/room/#entry_description","text":"entry_description: String Used to provide an additional description when entering a room.","title":"entry_description"},{"location":"documentation/room/#look_description","text":"look_description: String Used to provide a description of the Room.","title":"look_description"},{"location":"documentation/room/#room_name","text":"room_name: String In the default look() function, this is returned. Provides a convenient way to set the description of a Room for Rooms whose description does not change.","title":"room_name"},{"location":"documentation/room/#interactables","text":"interactables: Array[String] An array of Interactable identifier strings. These can be defined either in the Interactables script or in this Room's room_interactables property.","title":"interactables"},{"location":"documentation/room/#room_interactables","text":"room_interactables: InteractablesInterface Used to hold room specific Interactable s. These should be Interactable s that will never leave this room or be used elsewhere; therefore, they can share identifiers with other Interactable s in other Rooms . Notably, they will still be overridden by Interactable s with the same identifier in the Interactables script. For more information on how to interact with this property, see InteractablesInterface .","title":"room_interactables"},{"location":"documentation/room/#functions","text":"","title":"Functions"},{"location":"documentation/room/#get_room_in_direction","text":"get_room_in_direction(direction: Narrare.Direction) -> Room Returns the Room in the corresponding exit to direction , where direction is a Narrare.Direction . Returns null if there is no Room in that exit.","title":"get_room_in_direction"},{"location":"documentation/room/#look","text":"look() -> String By default, returns the value of look_description , but can be overridden for custom behaviour.","title":"look"},{"location":"documentation/room/#enter","text":"enter(from: Room) -> String BCompiles a description of the player entering the room from room_name , enter_<direction>_text , entry_description , and look() . from should be the Room that the player was in before entering this one. Note: does not actually change the player's position in the map; see Map for information on how to do that.","title":"enter"},{"location":"documentation/room/#enter_trigger","text":"enter_trigger() -> void By default, does nothing, but is called when the Room is entered. Override with custom behaviour if needed.","title":"enter_trigger"},{"location":"documentation/room/#exit_trigger","text":"exit_trigger() -> void By default, does nothing, but is called when the Room is exited. Override with custom behaviour if needed.","title":"exit_trigger"}]}